#### Kafka生产者

Kafka发送消息的主要步骤

![kafkaProdicer](../images/kafka/producer.png)



我们首先创建一个ProducerRecord对象，该对象包含目标主题和要发送的内容。我们还可以指定键和分区。发送对象时，生产者先把键和值的对象序列化成字节数组，以便它们能够在网络上传输。

数据传输到分区器后，如果指定了分区，分区器会根据主题和指定的分区，将数据发送到该主题的分区下，如果没有指定分区，分区器会根据键来选定一个分区。

#### 生成者配置

1. acks

acks 参数指定了必须有多少个分区副本收到消息，生产者才会认为消息写入成功。

* acks=0，生产者在成功写入消息之前不会等待任何来自服务器的响应。也就是说如果当中出现了问题导致服务器没有收到消息，那么生产者也就无从得知，消息也就丢失了。
* acks=1，只要集群的首领节点收到消息，生产者就会收到一个来自服务器的成功响应。
* acks=all，只有当所有的参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。

2. buffer.memory

该参数用来设置生产者内存缓冲区的大小，生产者用它来缓冲要发送到服务器的消息。如果应用程序发送的消息的速度超过发送到服务器的速度，会导致生产者空间不足。这个时候send方法调用要么被阻塞，要么抛出异常。

3. compression.type

默认情况下，消息发送不会被压缩。该参数可以设置为snappy,gzip,lz4。snappy算法在占用较少的CPU的情况下，可以提供较好的性能和可观的压缩比，如果比较关注性能和网络带宽，可以使用这种算法。gzip压缩算法一般会占用较多的CPU，但会提供较高的压缩比，所以网络带宽比较有限，可以使用这种算法。

4. retries

生产者可能从服务器收到临时性错误，如：分区找不到首领，在这种情况下，retries参数的值决定了生产者可以重发消息的次数。如果次数达到了，生产者会放弃重试并返回错误。默认情况下生产者会在每次重试之间等待100ms，所以建议设置重试次数和重试时间间隔之前，先测试一下恢复一个奔溃的节点需要多少时间（比如所有分区选出首领需要多少时间），让总的重试时间比kafka集群从崩溃中恢复的时间长，否则生产者会过早的放弃重试。在实际生产环境，我们只需要处理那些不可重试的错误（如：消息太大）或者重试次数超过上限的情况。

5. batch.size

当有多个消息需要被发送到同一个分区时，生产者会它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小。当批次被填满，批次里的所有的消息被发送出去，不过生产者不一定会等到批次被填满才发送，半满、甚至一个消息的批次也有可能被发送。

6. linger.ms

该参数指定生产者在发送批次之前等待更多消息加入批次的时间。默认情况下，只要有可用的线程，生产者就会把消息发送出去，就算批次里只有一个消息。

7. client.id

该参数可以是任何的字符串，服务器会用它来识别消息的来源，还可以用在日志和配额指标里。

8. max.in.flight.request.per.connection

指定生产者在收到服务器响应之前可以发送多少个消息，把它设置为1可以保证消息是按照发送的顺序写入到服务器的，即使发生了重试。

9. timeout.ms、request.timeout.ms和metadata.fetch.timeout.ms

request.timeout.ms指定了生产者在发送数据时等待服务器返回响应的时间

metadata.fetch.timeout.ms 指定了生产者在获取元数据（比如目标分区的首领是谁）时等待服务器返回的响应时间。

timeout.ms 指定了broker等待同步副本返回消息确认的时间与asks的配置相匹配。

10. max.block.ms 

指定在调用send()方法或者使用partitionsFor()方法获取元数据时生产者的阻塞时间。当生产者的发送缓存区已经满了，或者没有可以用的元数据时，这些方法会阻塞。在阻塞时间达到max.block.ms时，生产者会抛出异常。

11. max.request.size

用来控制生产者发送的请求大小。它可以指定能发送的单个消息的最大值，也可以指单个请求里所有消息总的大小。例如：假设这个值为1M，那么可以发送单个最大消息为1M,或者生产者可以在单个请求里发送一个批次，该批次包含了1000个消息，每个消息的大小为1K。另外broker也有自己可以接收消息的限制，所以最好两边的配置可以匹配。

12. receive.buffer.bytes和send.buffer.bytes

这两个参数分别指定了TCP socket接收和发送数据包的缓冲区大小，如果它们被设置为-1，就使用槽系统的默认值。

#### 分区

构建一个生产者对象（ProducerRecord）包含主题、键和值。Kafka的消息是一个个键值对。键的作用决定消息被写到主题的哪个区，拥有相同的键的消息将被写到同一个分区。

如果键的值为null，并且使用了默认的分区器，那么记录将被随机地发送到主题内各个可用的分区上。分区器使用轮询算法将消息均匀的分布到各个分区上。

如果键不为空，并且使用了默认的分区器，那么kafka会对键进行散列，然后根据散列值把消息映射到特定的分区上。同一个key会一直映射到同一个分区上，所以如果这个分区不可用。那么就会发生错误。