### 时间复杂度

#### 大O复杂表示法

算法的执行效率，粗略地讲，就是算法代码执行的时间。

```java
 int cal(int n) {//1
   int sum = 0;//2
   int i = 1;//3
   for (; i <= n; ++i) {//4
     sum = sum + i;//5
   }//6
   return sum;//7
 }//8
```

从cpu的角度来看，这段代码的每一行都执行者类似的操作：读数据-运算-写数据。我们假设每一行的代码执行时间是一样的，为unit_time。然后在这个假设的基础上，再来看看这个段代码的总执行时间：

第2、3段代码分别需要1个unit_time的执行时间，第4、5行都运行了n遍，所以需要2n*unit_time的执行时间，所以这段代码的总的执行时间就是(2n+2)*unit_time。可以看出来，**所有代码的执行时间T(n)与每行代码的执行次数成正比**。

按照这个思路，再来分析下面的代码：

```java
 int cal(int n) {//1
   int sum = 0;//2
   int i = 1;//3
   int j = 1;//4
   for (; i <= n; ++i) {//5
     j = 1;//6
     for (; j <= n; ++j) {//7
       sum = sum +  i * j;//8
     }//9
   }//10
 }//11

```

如上：第2、3、4行代码，每行代码都需要1个unit_time的执行时间，第5、6代码循环执行了n遍，需要2n*unit_time的执行时间，第7、8行代码执行了2n遍，所以需要(2n^2+2n+3)*unit_time。

综上我们可以总结一个规律：**所有代码的执行时间T(n)与每行代码的执行次数n成正比**，即：

```
T(n) = O(f(n))
```

T(n)表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。公式中的O表示代码执行时间(T(n))与f(n)表达式成正比。

所以第一个例子中的T(n)=O(2n+2)，第二个例子中的T(n) = O(2n^2+2n+3)。这就是**大O时间复杂度表示法**。大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随着数据规模增长的变化趋势**，所以也叫做**渐进时间复杂度**，简称**时间复杂度**。

#### 时间复杂度分析

大O这种复杂度表示法只是表示一种变化趋势，我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。**我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了**。

```java
 int cal(int n) {//1
   int sum = 0;//2
   int i = 1;//3
   for (; i <= n; ++i) {//4
     sum = sum + i;//5
   }//6
   return sum;//7
 }//8
```

如上第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有什么影响。循环次数最多的是第4、5行代码，这两行代码被执行了n次，所以总的时间复杂度是O(n)。

再看如下的例子：

```java
public int cal(int n){

        int sum_1 = 0;
        int p = 1;
        for (; p < 100; ++p){
            sum_1 = sum_1 + p;
        }

        int sum_2 = 0;
        int q = 1;
        for (;q < n;++q){
            sum_2 = sum_2+q;
        }

        int sum_3 = 0;
        int i = 1;
        int j = 1;
        for (; i <= n;++i){
            j = 1;
            for (; j <= n;++i){
                sum_3 = sum_3 + i*j;
            }
        }
    
        return sum_1 + sum_2 + sum_3;
    }
```

如上代码分为三部分，分别是sum_1、sum_2、sum_3，我们可以分别分析每一段代码的时间复杂度，然后把它们放到一块，再取一个量级最大的作为整段代码的复杂度。

第一段代码循环执行了100次，所以是一个常量的执行时间，跟n的规模无关。时间复杂度它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉，因为它本身对增长趋势并没有影响。

第二段和第三段代码的时间复杂度分别是O(n)和O(n2)。综合这三段代码，我们取其中最大的量级，所以整段代码的时间复杂度为O(n2)。也就是说：**总的时间复杂度就等于量级最大的那段代码的时间复杂度**。

抽像成公式为:如果T1(n) = O(f(n)),T2(n)=O(g(n))，那么T(n)=T1(n)+T2(n)=max(O(f(n)),O(g(n)))=O(max(f(n),g(n)))。