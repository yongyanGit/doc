### 高性能索引



#### 独立的列

独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。

> 试验数据来自sakila-db压缩包

```
explain select * from actor where  actor_id=166\G;
```

执行结果:

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: actor
         type: const
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 2
          ref: const
         rows: 1
        Extra: NULL
```

从执行结果type=const可以看出查询优化器使用了主键索引。

如果我们将查询条件改成一个表达式，那么将不会使用索引。

```
 explain select * from actor where  actor_id + 1=166\G;
```

执行结果：

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: actor
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 200
        Extra: Using where
```



说明：

执行结果中的type是用来表示访问数据行的方式，它有如下选项：

* all 全表扫描。
* index 扫描全表，但是按照索引进行扫描。
* range 范围扫描索引(between或者>符号)。
* ref  也是一种索引访问，返回所有匹配摸个值的行，可能有多个符合条件的行。
* const mysql对查询的部分优化，并且转换成一个常量，如：把主键当做where 条件，mysql就会把它转成一个常量。

extra列

* using index 说明mysql使用了覆盖索引，避免了访问表的数据行。
* using where 服务器在存储引擎收到行后将根据where条件进行过滤。
* using temorary 对查询结果进行排序时，使用了一张临时表
* using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行排序读取。





#### 前缀索引

有时候需要加索引的列的字符串很长，当为它加索引后，会使得索引空间变得大，索引效率低。这个时候可以截取该列数据的前缀来建索引。创建前缀索引既要保证选择的字符串不能太长而且它的选择性要高。



**创建前缀索引**

创建测试数据

```
create table city_demo (city varchar(50) not null);
insert into city_demo(city) select city from city;
update city_demo set city = (select city from city order by rand() limit 1);
```

先查询出最频繁出现的城市以及次数

```
select count(*) AS cnt ,city from city_demo group by city order by cnt desc limit 10;
```

```
+-----+-----------+
| cnt | city      |
+-----+-----------+
|  13 | Cuauhtmoc |
|  13 | Rizhao    |
|  13 | Oulu      |
|  11 | Shivapuri |
|  11 | Sivas     |
|  11 | Cianjur   |
|  11 | Dzerzinsk |
|  11 | Serpuhov  |
|  11 | Matamoros |
|  11 | Laohekou  |
+-----+-----------+
```

上面城市出现的的次数在11 ~13之间，然后查找最频繁出现的城市前缀，先从3个前缀字母开始：

```
select count(*) as cnt,left(city,3) as pref from city_demo group by pref order by cnt desc limit 10;
```

查询结果：

```
+-----+------+
| cnt | pref |
+-----+------+
|  69 | San  |
|  32 | Sou  |
|  32 | Tan  |
|  29 | Cha  |
|  29 | Kam  |
|  25 | Shi  |
|  25 | al-  |
|  24 | Man  |
|  22 | Sal  |
|  22 | Ben  |
+-----+------+
```

然后依次增加前缀的长度，直到前缀长度为7时，这个前缀的选择性与完整列的选择性差不多，所以前缀的长度为7比较合适。

```
+-----+---------+
| cnt | pref    |
+-----+---------+
|  16 | Santiag |
|  13 | Rizhao  |
|  13 | Cuauhtm |
|  13 | Oulu    |
|  11 | Laoheko |
|  11 | Dzerzin |
|  11 | Matamor |
|  11 | Shivapu |
|  11 | Serpuho |
|  11 | Cianjur
```

创建索引sql

```
alter table city_demo add key (city(7));
```

注意：

无法使用前缀索引做group by 和order by。

```
explain select * from city_demo order by city\G;
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: city_demo
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 3000
        Extra: Using filesort
```



#### 多列索引

在多个列上建立独立的单列索引大部分情况下并不能提高Mysql的查询性能。Mysql5.0之后引入了一种索引合并(index merge)的策略，可以使用表上的多个单列索引来定位指定的行。如下，actor_id和film_id上各有一个单列索引，查询时能够同时使用这两个列进行扫描，并将结果进行合并。

```
explain SELECT film_id,actor_id from film_actor where actor_id =1 or film_id =1\G
```

查询结果

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_actor
         type: index_merge
possible_keys: PRIMARY,idx_fk_film_id
          key: PRIMARY,idx_fk_film_id
      key_len: 2,2
          ref: NULL
         rows: 29
		Extra: Using union(PRIMARY,idx_fk_film_id); Using where
```

通过Extra可以看出查询使用了索引合并策略。索引合并策略有时候是一种优化的结果，但实际上说明表上的索引建的不合理。

当服务器对多个索引做联合操作时（多个or条件），通常需要耗费大量CPU和内存资源在算法的缓存、排序、和合并操作上，特别是索引的选择性不高时，需要合并扫描大量的数据。这个时候我们可以考虑将查询改成union方式。

```
explain SELECT film_id,actor_id from film_actor where actor_id =1 union select film_id,actor_id from film_actor where film_id =1 and actor_id <>1\G;
```

当服务器对多个索引做相交操作时（多个and条件）,意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。



#### 选择合适的索引列顺序

当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的，这个时候索引的作用只是用于优化where条件的查找，它能够最快的过滤出需要的行。

我们可以通过如下方法来判读列的选择性：

```
 select count(distinct staff_id)/count(*) as staff_id_selectivity, count(distinct customer_id)/count(*) as customer_id_selectivity, count(*) from payment\G;
```

```
*************************** 1. row ***************************
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               count(*): 16049
```

从查询结果可以看出customer_id的选择性更高。



#### 覆盖索引

如果一个索引包含所有需要查询的字段值，我们称之为“覆盖索引”。

**好处**：

*  索引条目通常远小于数据行大小，所以如果只读取索引，mysql会极大的减少数据访问量。
*  索引是按照列值(b+树是主键)顺序存储的，范围查询会比随机从磁盘读取每一行数据的I/O要少的多。
*  InnoDB的二级索引叶子节点保存了行的主键值，如果二级主键能够覆盖查询，可以避免对主键索引的二次查询。

```
explain select actor_id,film_id from film_actor \G;
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_actor
         type: index
possible_keys: NULL
          key: idx_fk_film_id
      key_len: 2
          ref: NULL
         rows: 5462
        Extra: Using index

```

上述查询使用了覆盖索引，查询的字段actor_id 和film_id都是索引列，mysql查询不用去数据列获取数据，直接在索引上获取列值。因此索引必须要存储索引列的值才能成为覆盖索引，即mysql只能使用b-treee索引做覆盖索引。

假如获取的列不是索引列

```
explain select * from film_actor where film_id = 1 and last_update like '%2006%'\G;
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_actor
         type: ref
possible_keys: idx_fk_film_id
          key: idx_fk_film_id
      key_len: 2
          ref: const
         rows: 10
        Extra: Using where

```

上面的查询没有覆盖索引：

* last_update 没有使用索引。
* mysql索引只运行做简单的操作如：等于、不等于、大于，最左前缀的LIKE查询。

