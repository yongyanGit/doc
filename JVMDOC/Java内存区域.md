#### Java内存区域

数据存储区域，对于这一块区域的划分，各个虚拟机有各自的划分方式，不过它们都必须遵从JAVA虚拟机的基本规范去实现。

![jvmarea](../images/jvm/jvmarea.png)

1. 程序计数器

可以看作是当前线程所执行的字节码的指示器，即字节码解释器工作时，通过改变这个指示器的值来选取下一条需要执行的字节码指令。如：循环、跳转、异常处理、线程恢复等。Java虚拟机的多线程运行是通过轮流切换线程并分配处理器执行的时间来实现的，为了保证当线程挂起并唤醒后，可以在它原来正确的位置继续执行，因此它是线程私有的。

如果线程线程执行的是方法，计算器记录的是当正在执行的虚拟机字节码指令的地址，如果执行的是native方法，则这个计数器为空。

**注**：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

2. Java虚拟机栈

与程序计数器一样，Java虚拟机栈也是线程私有的，并且生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧，用于存放局部变量表，操作数栈，动态链接、方法出口等信息。

* 局部变量表：存放了编译器可知的基本类型数据（boolean、byte、char、int、float、long、double）、对象引用，returnAddress类型（指向了一条字节码指令的地址）。其中64位的double、long占用2个局部变量空间（Slot），其余数据类型占用1个。局部变量的内存空间在编译期就确定了，在运行期不会改变它的大小。
* 操作数栈：它是一个后进先出（LIFO）栈，而它的长度也是在编译时期就写入了class文件当中，是固定的。它的作用就是提供字节码指令操作变量计算的空间

Java虚拟机栈会抛出两种异常：StackOverFlowError和OutOfMemoryError

* 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就会抛出StackOverFlowError。
* 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

3. 本地方法栈

和虚拟机栈发挥的作用相似，区别是：虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。在HotSpot虚拟机中和Java虚拟机栈合二为一。

本地方法被执行时，在本地方法栈也会创建一个栈帧，用来存放本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

4. 堆

Java虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆。从垃圾回收的角度，由于现在收集器基本都是采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代。再细致一点：Eden空间、From Survivor、To Survivor空间。

![heap](../images/jvm/heap.png)

在JDK1.8中移除整个永久代，取而代之的是一个叫做元空间（Metaspace)的区域,(永久代使用的是jvm的堆空间，而元空间使用的是物理内存，直接受到本机的物理内存的限制)

参考：<http://www.cnblogs.com/paddix/p/5309550.html>

5. 方法区

方法区与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有另外一个别名Non-Heap(非堆)，目的是与Java堆区分开来。

HotSpot虚拟机中方法区也常被称为永久代，本质上两者并不相等。仅仅是因为HotSpot虚拟机设计团队用永久代来实现方法区而已，这样HotSpot虚拟机的垃圾回收器就可以像管理Java堆一样管理这部分内存。但是这样做容易导致内存溢出问题。

相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就永久存在了。

6. 运行时常量池

运行时常量池是方法区的一部分。Class文件中除了有类、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符合引用）

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法申请到内存时，会抛出OutOfMemoryError异常。

Jdk1.7之后版本的JVM将运行时常量从方法区移除了，在Java堆中开辟了一块区域来存放运行时常量池。

![static](../images/jvm/static.png)

7. 直接内存

直接内存并不是虚拟机运行时数据的一部分，也不是虚拟机规范中定义的内存区域，但是这部分可以被频繁地使用。可能导致OutOfMemoryError。

JDK1.4中新加入的NIO类引入了一种基于通道与缓存区的i/o方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆之间来回复制数据。

直接内存的分配不会受到Java堆的限制，但是，既然内存就会受到本机总内存大小以及处理器寻址空间的限制。

