#### 垃圾回收算方法

1、标记－清除算法

算法分为两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收所有被标记的对象。标记－清除算法有两个缺点：一是效率问题，标记和清除的效率都不高，另一个是空间问题，标记清除之后会产生大量的不连续的内存碎片。空间碎片过多会导致程序运行过程中，如果有大对象产生，将无法找到足够大的连续内存而提前触发一次垃圾回收

![biaozhi](../images/jvm/biaozhi.jpeg)

2、复制算法

将内存按容量划分为大小相等的两块，每次只用其中一块，当这一块的内存用完了，就将还存活的对象复制到另外一块上，然后再把已经使用过的内存空间一次清理掉。这样使得每次都对半区进行内存回收，内存分配不用考虑内存碎片的问题。但是这种算法将内存的大小缩小了一半，代价太高。HotSpot的新生代采用的就是复制算法，因为新生代对象存活率不高，不用进行太多的复制。它将内存分为一块较大的Eden空间和两块较小的Survivor空间，大小比例是8:1，每次使用Eden和其中一块Survivor，也就是每次新生代可用内存为整个新生代容量大小的90%,只有10%会被浪费，JVM 每次触发垃圾回收，都会将存活的对象复制到另一块Survivor内存空间中，如果Survivor容量不够，则这些存活的对象会被存放到老年代。

![fuzhi](../images/jvm/fuzhi.jpeg)

3、标记－整理算法

复制算法在对象存活率较高时就要进行较多的复制操作，效率会变低。并且如果不想浪费50%的空间，就需要额外的空间进行担保，以应对被使用的内存中所有的对象都100%的存活的极端情况。如：老年代为新生代担保。

标记－整理与标记-清除过程一致，但后续步骤不是直接对可回收的对象进行清除，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![zhengli](../images/jvm/zhengli.jpeg)

