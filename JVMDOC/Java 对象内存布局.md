### Java 对象内存布局

以new语句为例，它编译成字节码将包含用来请求内存的new指令，以及用来调用构造器的invokespecial指令。

提到构造器，首先如果一个类没有定义任何构造器，Java编译器会自动添加一个无参的构造器，然后子类的构造器需要调用父类的构造器。如果父类存在无参构造器的话，该调用可以是隐式的，也就是Java编译器会自动添加对父类构造器的调用。但是，如果父类没有无参构造器，那么子类的构造器必须显式的调用父类带参数的构造器。

通过new指令新建出来的对象，它的内存其实涵盖了所有父类中的实例字段，也就是说，虽然子类无法访问父类的私有实例字段，或者子类的实例字段隐藏了父类的同名实例字段，但是子类的实例还是会为这些父类实例字段分配内存的。

#### 压缩指针

在Java虚拟机中，每个Java对象都有一个对象头，这个由标记字段和类型指针所构成。标记字段用来存放对象的运行数据如：哈希码、GC信息以及锁信息，而类型指针则指向该对象的类。

在64位的Java虚拟机中，对象头的标记字段占64位，而类型指针又占了64位。也就是说一个Java对象在内存中的额外开销就是16个字节。以Integer为例，它的基本类型只占4个字节，而每一个Integer对象额外内存开销至少是16个字节。这也是引入Java基本类型的原因。

为了减少对象的内存使用量，64位Java虚拟机引入了压缩指针的概念，将原本64位的Java对象指针压缩成32位。这样一来，对象头中的类型也会被压缩成32位，使得对象头的字节大小从16字节降至12字节。当然压缩指针不仅可以作用于对象头的类型指针，还可以用于引用类型的字段，以及引用类型数组。

压缩指针的原理，打个比方：路上全停着车，而且每个车恰好占据两个车位，也就是说停在0号和1号位上的0号车，停在1号和2号位上的1号车，以此类推。

原本的内存寻址用的是车号位，比如说我有一个值为6的指针，代表6号车位，那么沿着这个指针可以找到3号位。现在我们启用压缩指针，指针里面存的是车号，比如3代指3号车，当需要查找3号车时，我们应该将该指针的值乘以2，在沿着6号车位去找3号车。

上面通过车号(压缩指针)来寻址有一个要求,就是每辆车都是从偶数车位停起，这个概念我们称之为内存对齐。默认情况下，Java虚拟机中对象的起始地址需要对齐8的倍数，如果一个对象用不到8n个字节，那么空白的空间部分就浪费掉了，这些浪费掉的空间被称之为对象的填充。

默认情况下,Java虚拟机中的32位压缩指针可以寻址到2的35次方个字节，也就是32GB的地址空间。在对压缩指针引用时，我们需要将其左移动3位，再加上一个固定偏移量，便可以得到寻址32GB地址空间的伪64位指针。

当然关闭了压缩指针，Java虚拟机还是会进行内存对齐。此外内存对齐不仅在于对象与对象之间，也存在于对象中的字段之间，比如：Java虚拟机要求long字段、double字段以及非压缩指针状态下的引用字段地址为8的倍数。



