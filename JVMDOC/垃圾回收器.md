#### 垃圾回收器

1. Serial收集器

Serial（串行）收集器是一个单线程收集器。单线程意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作时，必须暂停其它所有的工作线程（Stop The World），直到它收集结束。

![seral](../images/jvm/serial.jpeg)

2. ParNew收集器

ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收算法策略）和Serial收集器一样。

![ParNew](../images/jvm/ParNew.jpeg)

3. Parallel Scavenge收集器

```
-XX:+UseParallelGC 
    使用Parallel收集器+ 老年代串行

-XX:+UseParallelOldGC
    使用Parallel收集器+ 老年代并行
```

Parallel Scavenge收集器类似于ParNew收集器。Parallel Scavenge收集器关注点是吞吐（高效率的利用CPU）。所谓吞吐量就是CPU中用于运行用户代码的时间与cpu总消耗时间的比值。

4. Serial Old收集器

Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一个用途作为CMS收集器的后备方案。

5. Parallel Old收集器

Parallel Old收集器的老年代版本。使用多线程和"标记-整理"算法。在注重吞吐量以及cpu资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。

6. CMS(Concurrent Mark Sweep)收集器

CMS是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。

CMS收集器使用"标记-清除"算法实现的，该算法会导致收集结束时会有大量空间碎片产生同时它无法处理浮动垃圾：

* 初始标记：暂停所有的线程，并记录下直接与root相连的对象。
* 并发标记：同时开启GC线程和用户线程，用一个闭包结构去记录可达对象。这个阶段结束，闭包结构不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法会跟踪记录这些发生引用更新的地方。
* 重新标记：重新标记是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般比初始标记标记阶段的时间稍长，远远比并发标记阶段时间短。
* 并发清除：开启用户线程，同时GC线程开始对标记的区域做清除。

![cms](../images/jvm/cms.jpeg)



7. G1收集器

G1(Gabage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器以及大容量内存的机器。它被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。

* 并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分其它收集器原本需要停顿Java用户线程来执行GC操作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
* 分代收集：G1可以不需要其它的收集器配合就可以独立管理整个GC堆，但是还是保留了分代的概念。
* 空间整合：与CMS的标记-清理算法不同，G1从整体来看是基于标记整理算法实现的收集器，从局部上来看是基于复制算法实现的。
* 可预测的停顿：G1相对于CMS的另一个优势，降低停顿时间是G1和CMS共同特点，但是G1除了追求低停顿外还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。





