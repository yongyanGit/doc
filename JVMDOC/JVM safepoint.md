### JVM safepoint

在JVM中为了防止回收仍被引用的对象内存而导致Java虚拟机崩溃，采用了一种Stop-the-world机制，即停止其它非垃圾回收线程的工作，直到完成垃圾回收。

安全点的初始目的不是让其它线程停下，而是找到一个稳定的执行状态，在这个执行状态下，Java虚拟机的堆栈不会发生变化，这么一来，垃圾回收器便能够安全地执行可达性分析。

举个例子：当Java程序通过JNI执行本地代码时，如果这段代码不访问Java对象、调用Java方法或者返回返回至原Java方法，那么Java虚拟机的堆栈就不会发生改变，也就代表着这段代码可以作为同一个安全点。

由于本地代码需要通过JNI的API来完成上述三个操作，因此Java虚拟机仅需在入口处进行安全点检测，测试是否有其它线程请求停留在安全点里，便可以在必要的时候挂起当前线程。

除了执行JNI本地代码外，Java线程还有其它几种状态：解释执行字节码、执行即时编译器生成的机器码和线程阻塞。阻塞的线程由于处于Java虚拟机线程调度器的掌控下，因此属于安全点

对于解释执行来说，字节码与字节码之间皆可作为安全点，Java虚拟机采取的做法是，当有安全点请求时，执行一条字节码便进行一次安全点检测。

执行即时编译器生成的机器码则比较复杂。由于这些代码直接运行在底层硬件之上，不受Java虚拟机掌控，因此生成机器码时，即时编译器需要插入安全点检测，以避免机器码长时间没有安全点检测的情况。HotSpot虚拟机的做法是在生成代码的方法出口以及非计数器循环的循环回边处插入安全检测点。