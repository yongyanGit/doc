代码在计算机中是以二进制指令的方式来执行的，当我们编写完一段代码后，需要通过编译器将程序汇编成二进制代码。如下C程序：

```c
int main(void) {
    int a = 1;
    int b = 2;
    a = a + b;
}
```

C程序是通过gcc编译器将源代码编译成可执行代码的。它的流程是：首先C预处理器扩展源代码，即插入#include命令指定的文件，并扩展所有用#define声明指定的宏；接着汇编器产生一个以```.s```结尾的汇编代码文件；最后汇编器将汇编代码转化成二进制目标文件，它以```.o```结尾。

对于一段C程序，我们可以使用```-S```选项来生成以```.s```结尾的汇编代码：

```c
gcc -Og -S main.c //main.c是C程序文件
_main:                                  
	pushq	%rbp
	movq	%rsp, %rbp
	xorl	%eax, %eax
	popq	%rbp
	retq
```

如果我们使用在C程序上使用```-c```指令，则GCC会**编译并汇编该代码**，产生```.o```结尾的目标代码：```gcc -Og -c main.c```。

还有一种情况，当我们已经生成了```.o```目标文件，然后需要查看汇编代码，这个需要对这个目标文件进行反汇编：```objdump -d main.o```。

```c
_main:
       0:	55 			pushq	%rbp
       1:	48 89 e5 	movq	%rsp, %rbp
       4:	31 c0 		xorl	%eax, %eax
       6:	5d 			popq	%rbp
       7:	c3 			retq

```

从上面的汇编代码我们可以得出，程序的执行其实就是指令的执行。

大多数汇编代码指令都有一个后缀用来表明操作指令操作的数据的大小。例如，数据传送指令有四个变种：movb(传送字节)、movw(传送字)、movl(传送双字)和movq(传送四字)。Intel用术语“字(word)”表示16位数据类型。32位数为“双字(double words)”，后缀用l(long word)来表示；同理称64位数为“四字(quad words)”，后缀q。(双精度的指令不同去其他指令，所以不会和双字搞混)

![](../images/cs/1.png)

大多数指令有一个或多个操作数，操作数是指指令后面的的参数，如：

```movq %rsp, %rbp```，中%rsp，%rbp就是操作数。操作数指明一个操作中要使用的源数据值以及放置结果的目的位置。源数据可以以常数的形式给出或是从寄存器会内存中读出。结果可以存放在寄存器或内存中。**操作数**可以分为三种：

- 立即数：书写方式是'$'后面跟一个用标准C表示的整数，比如，\$-577或者\$0x1f。不同的指令允许的立即数值范围不同。
- 寄存器：它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节分别对应于8位、16位、32位 或64位。我们用r$_a$来表示任意寄存器a，用引用R[r$_a$]来表示它的值。这里将寄存器集合看成一个数组R，用寄存器标识符作为索引。
- 内存引用：它会根据计算出来的地址访问某个内存位置。我们可以把内存看成一个很大的字节数组，用符号M$_b$[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用。

不同的操作可以组成多种不同的寻址模式，允许不同形式的内存引用。如下图，表中底部用语法Imm(r$_b$,r$_i$,s)表示的是最常用的形式。这样的引用有四部分组成：一个立即数偏移Imm，一个基址寄存器r$_b$，一个变址寄存器r$_i$和一个比例因子s，这里的s必须是1、2、4、8。基址和变址寄存器都必须是64位寄存器。有效地址被计算为Imm+R[r$_b$]+R[r$_i$]*s。

![](../images/cs/3.png)

