### 算术和逻辑操作

![](../images/cs/11.png)

#### 加载有效地址

leaq指令从内存读取数据到寄存器，但实际上它根本没有引用内存，它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将**有效地址**写入到**目的操作数**。另外它还可以进行普通的算术运算，比如：如果寄存器%rdx的值为x，那么leaq7(%rdx,%rdx,4)，它将设置寄存器%rax(返回寄存器)的值为5x+7。

> lea base_address(offset_address,index,size),%rax  它的计算公式为：base_address+offset_address+index*size

例子：

```
long scale(long x,long y,long z){
    long t = x+4*y+12*z;
    return t;
}
```

编译时，该函数的算术运算以三条指令实现：

![](../images/cs/12.png)

#### 一元和二元操作

一元操作只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。比如说，指令incq(%rsp)会使栈顶的8字节元素加1。

二元操作，其中第二个操作数既是源又是目的。例如：指令subq %rax,%rdx，使寄存器%rdx的值减去%rax中的值。第一个操作数可以是立即数、寄存器或内存位置。第二个操作数可以是寄存器或内存位置，注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，把结果写回内存。

#### 移位操作

移位操作，第一个操作数是移位量，第二项是要移位的数，可以进行算是和逻辑移位。移位量可以是一个立即数，或者放在单字节寄存器%c1中。在x86-64中，对w位长的数据值进行操作，移位量是由%c1寄存器的低m位决定，这里2$^m$=w。所以当寄存器%c1的十六进制值为0xFF时，指令salb会移动7位，salw会移动15位，sall会移动31位，而salq会移动63位。

左移指令有两个名字：SAL 和SHL，两者的效果是一样的，都是右边填上0.右移指令不同，SAR执行算术移位(填上符号位)，而SHR执行逻辑移位(填上0)。

![](../images/cs/13.png)

