### 网络模型

OSI就是我们常说的7层网络协议，它把网络分成了7层，每层都有自己的功能，并且逐层叠加。

| 数据单元        | 分层              | 介绍                                                    |
| --------------- | ----------------- | ------------------------------------------------------- |
| 数据层(Data)    | 第7层：应用层     | 为上层应用，例如：HTTP、FTP、DNS协议等                  |
| 数据层(Data)    | 第6层：表示层     | 进行数据压缩、编码、加密                                |
| 数据层(Data)    | 第5层：会话层     | 定义会话协议，例如：SOCKS、PPTP等                       |
| 数据段(Segment) | 第4层：传输层     | 提供传输控制相关的功能，是TCP所在层                     |
| 数据包(Packet)  | 第3层：网络层     | 提供地址分配以及设备间的路由传输功能，是IP所在的层      |
| 数据帧(Frame)   | 第2层：数据链路层 | 提供点对点的直连CRC等功能，是MAC码所在的层              |
| 比特(Bit)       | 第1层：物理层     | 提供具体的电器连接定义功能，比如百兆以太往 ，无线网等。 |

以上7层都有自己要提供的功能并解决一个相应的问题。但是第5、6、7层在实践中没有严格的定义和边界。

#### 层间的数据包装

在OSI中，每一层都使用下一层的协议和服务，具体表现为每一层的数据都包含自己的一个包头，这个包头包含本层定义的典型信息。

从数据链路层到TCP层，每一层都在下一层的数据上增加了一个包头，进而形成最终的数据。

![netfloor](../images/net/netfloor.png)

一个TCP/UDP的数据包在数据上分别加了TCP/UDP自己的头(TCP/UDP Header)，IP头(IPHeader)、数据链路层的Frame头(FrameHeader)及Frame尾(FrameFooter)。而一个Frame包的长度一般固定在1500Byte或稍小，我们称之为MTU。

### UDP与IP头

1. UDP的头

UDP的头一共有64位，由4个16位的参数组成，包括源端口、目标端口、数据长度和校验位。

| 长度         | 名称             | 说明                                  |
| ------------ | ---------------- | ------------------------------------- |
| 2byte(16bit) | Source port      | 来源端口、支持最大2^16即65535个端口号 |
| 2byte(16bit) | Destination port | 目标端口，支持最大2^16即65535个端口号 |
| 2byte(16bit) | Length           | 是整个UDP头和UDP数据的长度            |
| 2byte(16bit) | ECNChcksum       | 校验(checksum),在IPV4中可选           |

UDP非常简单，只是对ip扩展了目标端口和来源端口，能区分应该将数据给哪个程序，并增加了一个校验的功能。

现在使用UDP的典型协议是DNS、DHCP等老牌的互联网协议。而DNS协议的请求不需要建立长连接，因此可以使用这种比较简单有效的协议。

2. IP的头

![ipheader](../images/net/ipHeader.png)

IP头的标准长度是20Byte(160bit)，如果有额外的字段，则会更长一些。

| 长度    | 名称                                     | 说明                                                         |
| ------- | ---------------------------------------- | ------------------------------------------------------------ |
| 4bit    | Version                                  | 指IP的版本，目前值为4                                        |
| 4bit    | IHL(Internet Header Length)              | 指IP头的长度，最小的有效值是5，字段的最大值是2^4，即16，其每加1代表增加32bit,若值为5，则是5*32bit=160bit，刚好指向数据头的大小 |
| 6bit    | DSCP(Differentiated Services Code Point) | 区分服务                                                     |
| 2bit    | ECN(Explicit Congestion Notification)    | 显示拥塞通告                                                 |
| 16bit   | Total Length                             | 整个IP包的长度，包括头和数据                                 |
| 16bit   | Identication                             | 旧的定义，现在应该为废弃状态                                 |
| 8bit    | Flags                                    | 状态位，目前只有IP是否分片的定义                             |
| 8bit    | Fragment Offset                          | 分片偏移，为IP出现分片时使用的分片偏移                       |
| 8bit    | TTL(Time To Live)                        | 防止IP包在路由间形成死循环，设置被路由转发的最大次数，这里最大是2^8，即255 |
| 4bit    | Protocol                                 | 上层使用的协议，例如1是ICMP，6是TCP，17是UDP                 |
| 16bit   | Header Chcksum                           | Ip头的头部校验和，这里是一个简单的摘要算法，验证ip头的头部是否正确 |
| 32bit   | Source IP Address                        | IP源地址                                                     |
| 32bit   | Destination IP Address                   | IP的目标地址，路由通过其转发ip包                             |
| n*32bit | 可选参数                                 | 当IHL为5时，这里是数据的开始                                 |

IPv4的头包含13个字段，并可通过IHL指针在20个字节后再扩展，注意这些字段是大端序(Big-Endian)的。

Ipv6的头的定义更偏向使用可选字段以及动态的头长度，因此其默认的字段更少一些，其目标和源IP地址变成64bit。

3. IP未解决的问题

IP用于控制传输的字段非常简单，而且没有在UDP中的数据校验数据校验和保证基本传输的字段。因此如果只依赖ip，会有以下问题：

* 损坏数据：在传输中数据被改变或部分丢失，Ipv4只校验自己的IP包头是否正确，而IPv6连默认的包头校验的字段都没有了。
* 丢失数据包：整个IP包没有到达，很可能是在传输中因为各种原因丢失了，比如网络拥塞被路由器丢掉。
* 重复到来：IP包在路由传输的过程中很可能被重复发送。
* 数据包乱序：因为各个IP包独自经过路由，所以很可能出现4个IP包的发送顺序是A、B、C、D，到达顺序却是C、B、A、D。

通过对IP的分析，我们就可以较好的理解UDP所做的事情，UDP比IP主要增加了如下两个功能：

* 增加了一个源端口号和目标端口号，通过它们可以解决将IP包传给哪个程序的问题。
* 增加一个校验和，可以发现这个包的数据在传输的过程中是否损坏，但是不能解决上面所说的丢失数据包、重复到来、数据包乱序等问题。



#### TCP 详解

1. TCP头

![tcpHeader](../images/net/tcpHeader.png)



| 长度         | 名称                  | 说明                                                         |
| ------------ | --------------------- | ------------------------------------------------------------ |
| 2Byte(16bit) | Source Port           | 来源端口，这里支持最大2^16即65535个端口号，同UDP             |
| 2Byte(16bit) | Destination Port      | 目标端口，这里支持最大2^16即65535个端口号，同UDP             |
| 4Byte(32bit) | Sequence Number       | 发送序列号码，这里支持最大2^32即4G大小的序列号               |
| 4Byte(32bit) | Acknowledgment Number | 确认序列号码，这里支持最大2^32即4G大小的序列号，在这里是flag中ACK为1时有效 |
| 4bit         | Data Offset           | 数据偏移量，这里指向数据的开始，也是TCP头的长度，其最小的有效值是5，如果有可选的字段，则其值会大于5，小于2^4，即最大为15；其每加1代表头的长度增加32bit。若值为5，则是5*32bit=160bit，刚好指向数据头的范围 |
| 3bit         | Reserved              | 保留字段，暂时保留，其值为000                                |
| 9bit         | Flags                 | 标志位                                                       |
| 16bit        | Window Size           | 活动窗口的大小                                               |
| 16bit        | Checksum              | 校验和，为TCP头和后面数据的整体校验和                        |
| 16bit        | Urgent pointer        | 紧急指针，指向需要紧急处理的数据位置                         |
| n*32bit      | 可选参数              | 若Data offset为5，则这里是数据的开始                         |

其中TCP包头中的flags如下：

![flags](../images/net/flags.png)

这里9个标志及其意义如下：

![flaguse](../images/net/flagUse.png)

Sequence Number：发送序列号，为了解决乱序的问题。

Acknowledgment Numbe：确认序号，发送出去的包应该有确认，确保知道对方有没有收到，如果没有收到就应该重新发送，直到到达。这个可以解决不丢包的问题。

活动窗口大小，TCP要做流量控制，通信双方各声明一个窗口，标识自己当前能够处理能力，防止发送数据太快或者发送太慢。除了做流量控制外，TCP还会做拥塞控制，控制发送的速度。

TCP头中不像在UDP头中有个16bit的定义包长度的字段Lengh，在这里，TCP可以通过如下方式得到数据的开始位置：

```
IP的协议里的总长度 - IP头长度(IHL) -TCP头的长度(Data Offset)
```

2. TCP的传输流程

* TCP 的三次握手



我们将TCP中的角色分为发送端和接收端，发送端和接收端需要先通过握手确认建立对方的连接，在建立连接后，双方可以通过SEQ序号和ACK序号来交流数据的发送和接收。

我们可以将发送数据和接收数据的过程理解为如下：发送端发送一条SEQ=1的数据，然后等待接收端返回，它期望返回SEQ+1的ACK，即ACK=2；当收到ACK=2时，发送端再发送SEQ=2，之后再等待接收端返回，它期望返回SEQ+1的ACK，即ACK=3；当收到ACK=3时，发送端再发送SEQ=3的数据。

![ack](../images/net/ack.png)

如果发送端没有收到接收端的确认消息，会触发超时重发，重发上条消息，即当发送端期望返回ACK3但未收到时，在超时后又重发了SEQ=2的消息。

![ack2](../images/net/ack2.png)



![ack2](../images/net/ack2.png)

3. 滑动窗口下的TCP传输流程

上面的接收、确认消息以及超时重发的模式，是有性能延迟的。滑动窗的引入良好地解决了TCP的性能问题，TCP这时可以同时发送窗口内的多个数据，并动态地等待这一批数据的确认反馈。

TCP可以一次发送SEQ=2、SEQ=3、SEQ4的消息，当发送端接收到ACK=5时，再发送SEQ=5、SEQ=6、SEQ=7的消息。

![ack3](../images/net/ack3.png)

在批量发送的数据中有丢失时会要求重传，如：发送端在发送完SEQ=5、SEQ=6、SEQ=7的消息后，应该收到连续的SEQ+1的ACK，即ACK=8；但是发送端只收到了ACK=6，即接收端按顺序只收到了SEQ=5的数据，后续需要先补发一条SEQ=6的数据；接收端在收到SEQ6的数据后会返回ACK=8。

![ack4](../images/net/ack4.png)

我们可以认为ACK在滑动窗口下的返回规则是：只返回收到的连续的SEQ的最大值对应的ACK，比如：对于批量数据，发送端发送了SEQ：1,2,3,4,5,6,7,8,9,10，而接收端只收到了1,2,3,4,5,,7,8,9,10，缺少6，所以接收端只能返回SEQ为5的ACK。这时如果发送端仅需要补发SEQ=6这条数据，之后接收端可以发送ACK=11的响应。

4. 通过TCP解决传输问题

* 数据损坏：通过Checksum，接收端发现校验和不一致后通过返回ACK序号告知发送端重发数据。
* 丢失数据包：接收端在发现缺少序号后，会通过ACK序号来告知发送端没有收到哪个包，然后发送端重发这个数据。
* 重复到来：因为发送序号，所以接收端可以直接判断当前的数据是重复数据并丢弃。
* 数据包乱序：在使用窗口/滑动窗口时出现，接收方会根据发送端的SEQ序号正确的缓存数据，所以乱序不会影响传输。而TCP让上层协议看见的都是有序的数据

