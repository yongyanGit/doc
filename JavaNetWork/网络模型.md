### 网络模型

OSI就是我们常说的7层网络协议，它把网络分成了7层，每层都有自己的功能，并且逐层叠加。

| 数据单元        | 分层              | 介绍                                                    |
| --------------- | ----------------- | ------------------------------------------------------- |
| 数据层(Data)    | 第7层：应用层     | 为上层应用，例如：HTTP、FTP、DNS协议等                  |
| 数据层(Data)    | 第6层：表示层     | 进行数据压缩、编码、加密                                |
| 数据层(Data)    | 第5层：会话层     | 定义会话协议，例如：SOCKS、PPTP等                       |
| 数据段(Segment) | 第4层：传输层     | 提供传输控制相关的功能，是TCP所在层                     |
| 数据包(Packet)  | 第3层：网络层     | 提供地址分配以及设备间的路由传输功能，是IP所在的层      |
| 数据帧(Frame)   | 第2层：数据链路层 | 提供点对点的直连CRC等功能，是MAC码所在的层              |
| 比特(Bit)       | 第1层：物理层     | 提供具体的电器连接定义功能，比如百兆以太往 ，无线网等。 |

以上7层都有自己要提供的功能并解决一个相应的问题。但是第5、6、7层在实践中没有严格的定义和边界。

#### 层间的数据包装

在OSI中，每一层都使用下一层的协议和服务，具体表现为每一层的数据都包含自己的一个包头，这个包头包含本层定义的典型信息。

从数据链路层到TCP层，每一层都在下一层的数据上增加了一个包头，进而形成最终的数据。

![netfloor](../images/net/netfloor.png)

一个TCP/UDP的数据包在数据上分别加了TCP/UDP自己的头(TCP/UDP Header)，IP头(IPHeader)、数据链路层的Frame头(FrameHeader)及Frame尾(FrameFooter)。而一个Frame包的长度一般固定在1500Byte或稍小，我们称之为MTU。



### UDP与IP头

1. UDP的头

UDP的头一共有64位，由4个16位的参数组成，包括源端口、目标端口、数据长度和校验位。

| 长度         | 名称             | 说明                                  |
| ------------ | ---------------- | ------------------------------------- |
| 2byte(16bit) | Source port      | 来源端口、支持最大2^16即65535个端口号 |
| 2byte(16bit) | Destination port | 目标端口，支持最大2^16即65535个端口号 |
| 2byte(16bit) | Length           | 是整个UDP头和UDP数据的长度            |
| 2byte(16bit) | ECNChcksum       | 校验(checksum),在IPV4中可选           |

UDP非常简单，只是对ip扩展了目标端口和来源端口，能区分应该将数据给哪个程序，并增加了一个校验的功能。

现在使用UDP的典型协议是DNS、DHCP等老牌的互联网协议。而DNS协议的请求不需要建立长连接，因此可以使用这种比较简单有效的协议。

2. IP的头

![ipheader](../images/net/ipHeader.png)

IP头的标准长度是20Byte(160bit)，如果有额外的字段，则会更长一些。

| 长度    | 名称                                     | 说明                                                         |
| ------- | ---------------------------------------- | ------------------------------------------------------------ |
| 4bit    | Version                                  | 指IP的版本，目前值为4                                        |
| 4bit    | IHL(Internet Header Length)              | 指IP头的长度，最小的有效值是5，字段的最大值是2^4，即16，其每加1代表增加32bit,若值为5，则是5*32bit=160bit，刚好指向数据头的大小 |
| 6bit    | DSCP(Differentiated Services Code Point) | 区分服务                                                     |
| 2bit    | ECN(Explicit Congestion Notification)    | 显示拥塞通告                                                 |
| 16bit   | Total Length                             | 整个IP包的长度，包括头和数据                                 |
| 16bit   | Identication                             | 旧的定义，现在应该为废弃状态                                 |
| 8bit    | Flags                                    | 状态位，目前只有IP是否分片的定义                             |
| 8bit    | Fragment Offset                          | 分片偏移，为IP出现分片时使用的分片偏移                       |
| 8bit    | TTL(Time To Live)                        | 防止IP包在路由间形成死循环，设置被路由转发的最大次数，这里最大是2^8，即255 |
| 4bit    | Protocol                                 | 上层使用的协议，例如1是ICMP，6是TCP，17是UDP                 |
| 16bit   | Header Chcksum                           | Ip头的头部校验和，这里是一个简单的摘要算法，验证ip头的头部是否正确 |
| 32bit   | Source IP Address                        | IP源地址                                                     |
| 32bit   | Destination IP Address                   | IP的目标地址，路由通过其转发ip包                             |
| n*32bit | 可选参数                                 | 当IHL为5时，这里是数据的开始                                 |

IPv4的头包含13个字段，并可通过IHL指针在20个字节后再扩展，注意这些字段是大端序(Big-Endian)的。

Ipv6的头的定义更偏向使用可选字段以及动态的头长度，因此其默认的字段更少一些，其目标和源IP地址变成64bit。

3. IP未解决的问题

IP用于控制传输的字段非常简单，而且没有在UDP中的数据校验数据校验和保证基本传输的字段。因此如果只依赖ip，会有以下问题：

* 损坏数据：在传输中数据被改变或部分丢失，Ipv4只校验自己的IP包头是否正确，而IPv6连默认的包头校验的字段都没有了。
* 丢失数据包：整个IP包没有到达，很可能是在传输中因为各种原因丢失了，比如网络拥塞被路由器丢掉。
* 重复到来：IP包在路由传输的过程中很可能被重复发送。
* 数据包乱序：因为各个IP包独自经过路由，所以很可能出现4个IP包的发送顺序是A、B、C、D，到达顺序却是C、B、A、D。

通过对IP的分析，我们就可以较好的理解UDP所做的事情，UDP比IP主要增加了如下两个功能：

* 增加了一个源端口号和目标端口号，通过它们可以解决将IP包传给哪个程序的问题。
* 增加一个校验和，可以发现这个包的数据在传输的过程中是否损坏，但是不能解决上面所说的丢失数据包、重复到来、数据包乱序等问题。



#### TCP 详解

1. TCP头

![tcpHeader](../images/net/tcpHeader.png)



| 长度         | 名称                  | 说明                                                         |
| ------------ | --------------------- | ------------------------------------------------------------ |
| 2Byte(16bit) | Source Port           | 来源端口，这里支持最大2^16即65535个端口号，同UDP             |
| 2Byte(16bit) | Destination Port      | 目标端口，这里支持最大2^16即65535个端口号，同UDP             |
| 4Byte(32bit) | Sequence Number       | 发送序列号码，这里支持最大2^32即4G大小的序列号               |
| 4Byte(32bit) | Acknowledgment Number | 确认号码，这里支持最大2^32即4G大小的序列号，在这里是flag中ACK为1时有效 |
| 4bit         | Data Offset           | 数据偏移量，这里指向数据的开始，也是TCP头的长度，其最小的有效值是5，如果有可选的字段，则其值会大于5，小于2^4，即最大为15；其每加1代表头的长度增加32bit。若值为5，则是5*32bit=160bit，刚好指向数据头的范围 |
| 3bit         | Reserved              | 保留字段，暂时保留，其值为000                                |
| 9bit         | Flags                 | 标志位                                                       |
| 16bit        | Window Size           | 活动窗口的大小                                               |
| 16bit        | Checksum              | 校验和，为TCP头和后面数据的整体校验和                        |
| 16bit        | Urgent pointer        | 紧急指针，指向需要紧急处理的数据位置                         |
| n*32bit      | 可选参数              | 若Data offset为5，则这里是数据的开始                         |

其中TCP包头中的flags如下：

![flags](../images/net/flags.png)

这里9个标志及其意义如下：

![flaguse](../images/net/flagUse.png)

TCP的核心接收序号和确认序号，通过它们可以在中途有数据丢失的情况下，通过返回ACK的序号进行重发。

在TCP的头定义中处理紧急指针，其它字段都是传输控制相关的，而紧急指针是数据流控制相关的。当应用程序以数据流(Stream)的方式处理从网络上接收的数据时，紧急指针可以跳过其它部分直接指向所需要处理的数据，例如需要直接跳过其它部分来处理错误信息的情况。

我们发现在TCP头中不像在UDP头中有个16bit的定义包长度的字段Lengh，在这里，TCP可以通过如下方式得到数据的开始位置：

```
IP的协议里的总长度 - IP头长度(IHL) -TCP头的长度(Data Offset)
```

2. TCP的传输流程

我们将TCP中的角色分为发送端和接收端，发送端和接收端需要先通过握手确认建立对方的连接，在建立连接后，双方可以通过SEQ序号和ACK序号来交流数据的发送和接收。

